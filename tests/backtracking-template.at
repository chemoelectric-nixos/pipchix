# Copyright © 2026 Barry Schwartz
#
# This file is part of Pipchix.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of Pipchix and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#

AT_SETUP([setup_message(backtracking)])

AT_KEYWORDS([default_keywords backtracking])

m4_define([sexpr],
  [(scheme->nix
    (let ((x 1234))
      (attempt-every-ec
        (begin
          (set! x 5678)))
      x))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(5678)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((x 1234))
      (attempt-every-ec
        (begin
          (fail)
          (set! x 5678)))
      x))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(1234)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((x 1234))
      (attempt-every-ec
       (begin
         (reversible-set! ((x 5678))
           x)))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(5678)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((x 1234))
      (attempt-every-ec
       (begin
         (reversible-set! ((x 5678)))))
      x))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(5678)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((x 1234)
          (y "1234"))
      (attempt-every-ec
       (begin
         (reversible-set! ((x 5678)
                           (y "5678"))
           (unless (and (= x 5678) (equal? y "5678"))
             (raise "BIG ERROR"))
           (fail))))
      (list x y)))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·(1234)·("1234")·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((x (vector 1234))
          (y (vector "1234")))
      (attempt-every-ec
       (begin
         (reversible-vector-set! (((x 0) 5678)
                                  ((y 0) "5678"))
           (unless (and (= (vector-ref x 0) 5678)
                        (equal? (vector-ref y 0) "5678"))
             (raise "BIG ERROR"))
           (fail))))
      (list (vector-ref x 0) (vector-ref y 0))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·(1234)·("1234")·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((x (list 1234))
          (y (list "1234")))
      (attempt-every-ec
       (begin
         (reversible-list-set! (((x 0) 5678)
                                ((y 0) "5678"))
           (unless (and (= (list-ref x 0) 5678)
                        (equal? (list-ref y 0) "5678"))
             (raise "BIG ERROR"))
           (fail))))
      (list x y)))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·[·(1234)·]·[·("1234")·]·]·]])],[])

dnl  A simple n-queens using attempt-every-ec for looping (but not
dnl  for ‘real’ backtracking).
m4_define([sexpr],
  [(scheme->nix
    (let ()
      (define (make-queen x y) (cons x y))
      (define (queen-x q) (car q))
      (define (queen-y q) (cdr q))
      (define (n-queens n)
        (define (queens-attack? q1 q2)
          (let ((x2-x1 (- (queen-x q2) (queen-x q1))))
            (if (zero? x2-x1)
              @%:@t
              (let ((y2-y1 (- (queen-y q2) (queen-y q1))))
                (if (= (abs x2-x1) (abs y2-y1))
                  @%:@t
                  @%:@f)))))
        (define (latest-queen-attacks? q*)
          (let ((latest-queen (car q*)))
            (let loop ((q* (cdr q*)))
              (if (pair? q*)
                (if (queens-attack? latest-queen (car q*))
                  @%:@t
                  (loop (cdr q*)))
                @%:@f))))
        (define solutions (list-ec (:range x 1 (+ n 1))
                                   (list (make-queen x 1))))
        (do ((y 2 (+ y 1)))
            ((= y (+ n 1)))
          (let ((solut (list-ec (:list q* solutions)
                                (:range x 1 (+ n 1))
                                (cons (make-queen x y) q*))))
            (set! solutions '\''())
            (attempt-every-ec
              (:list q* solut)
              (begin
                (when (latest-queen-attacks? q*)
                  (fail))
                (set! solutions (cons q* solutions))))))
        solutions)
        (length (n-queens 8))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(92)·])],[])

dnl  Stephen B. Wampler’s solution to the n-queens problem, translated
dnl  from Icon to Scheme.
m4_define([sexpr],
  [(scheme->nix
    (let ()
      (define (n-queens n)
        (define recorded-solutions '\''())
        (define solution (make-vector (+ n 1)))
        (define (record-solution)
          (set! recorded-solutions
            `(,(list-ec (:range c 1 (+ n 1))
                        `(,c . ,(vector-ref solution c)))
              ,@recorded-solutions)))
        (define rows (make-vector (+ n 1) 0))
        (define up (make-vector (+ n n) 0))
        (define down (make-vector (+ n n) 0))
        (attempt-every-ec
          (let recurs ((c 1))
            (attempt-every-ec
              (:range r 1 (+ n 1))
              (and (zero? (vector-ref rows r))
                   (zero? (vector-ref up (+ n r (- c))))
                   (zero? (vector-ref down (+ r c -1))))
              (reversible-vector-set! (((rows r) 1)
                                       ((up (+ n r (- c))) 1)
                                       ((down (+ r c -1)) 1))
                (vector-set! solution c r)
                (if (= c n)
                  (begin
                    (record-solution)
                    (recurs 1))
                  (recurs (+ c 1)))))
            (fail) ))
        recorded-solutions)
      (length (n-queens 8))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(92)·])],[])

dnl  A program that finds one solution to the n-queens by brute force
dnl  search through permutations of letters representing columns. Both
dnl  attempt-and-ec and attempt-or-ec are used.
m4_define([sexpr],
  [(scheme->nix
    (let ()
      (define (permutations lst)
        (if (null-list? lst)
          (quote (()))
          (append-ec
            (:list p (permutations (cdr lst)))
            (let ((end (+ (length p) 1)))
              (list-ec
                (:range n 0 end)
                (let insert ((π p)
                             (ν n))
                  (if (zero? ν)
                    `(,(car lst) ,@π)
                    `(,(car π) ,@(insert (cdr π) (- ν 1))))))))))
      (define (permutation-solves-n-queens? lst)
        (let ((n (length lst))
              (result @%:@f))
          (attempt-every-ec
            (begin
            (attempt-and-ec
              (:range y1 0 n)
              (:range y2 (+ y1 1) n)
              (let ((xdiff (- (char->integer (list-ref lst y2))
                              (char->integer (list-ref lst y1))))
                    (ydiff (- y2 y1)))
                (if (= (abs xdiff) (abs ydiff))
                  (fail))))
            (set! result @%:@t)))
          result))
      (define (find-n-queens-solution start)
        (attempt-or-ec
        (:list p (permutations start))
        (if (permutation-solves-n-queens? p)
          p
          (fail))))
      (map string
       (find-n-queens-solution
        '\''(@%:@\a @%:@\b @%:@\c @%:@\d @%:@\e @%:@\f @%:@\g @%:@\h)))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·("e")·("b")·("f")·("a")·("g")·("d")·("h")·("c")·]·]])],[])

dnl  A program that finds one solution to the n-queens by brute force
dnl  search through permutations of letters representing columns. Both
dnl  attempt-and-ec and attempt-while-ec are used.
m4_define([sexpr],
  [(scheme->nix
    (let ()
      (define (permutations lst)
        (if (null-list? lst)
          (quote (()))
          (append-ec
            (:list p (permutations (cdr lst)))
            (let ((end (+ (length p) 1)))
              (list-ec
                (:range n 0 end)
                (let insert ((π p)
                             (ν n))
                  (if (zero? ν)
                    `(,(car lst) ,@π)
                    `(,(car π) ,@(insert (cdr π) (- ν 1))))))))))
      (define (permutation-solves-n-queens? lst)
        (let ((n (length lst))
              (result @%:@f))
          (attempt-every-ec
            (begin
            (attempt-and-ec
              (:range y1 0 n)
              (:range y2 (+ y1 1) n)
              (let ((xdiff (- (char->integer (list-ref lst y2))
                              (char->integer (list-ref lst y1))))
                    (ydiff (- y2 y1)))
                (if (= (abs xdiff) (abs ydiff))
                  (fail))))
            (set! result @%:@t)))
          result))
      (define (find-n-queens-solution start)
        (let ((solution @%:@f))
          (attempt-while-ec
            (:list p (permutations start))
            (begin (set! solution p))
            (when (permutation-solves-n-queens? p)
              (fail)))
          solution))
      (map string
       (find-n-queens-solution
        '\''(@%:@\a @%:@\b @%:@\c @%:@\d @%:@\e @%:@\f @%:@\g @%:@\h)))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·("e")·("b")·("f")·("a")·("g")·("d")·("h")·("c")·]·]])],[])

AT_CLEANUP

# local variables:
# mode: autoconf
# coding: utf-8
# end:
