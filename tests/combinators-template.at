# Copyright © 2026 Barry Schwartz
#
# This file is part of Pipchix.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of Pipchix and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#

AT_SETUP([setup_message(combinators)])

AT_KEYWORDS([default_keywords combinators])

m4_define([sexpr],
  [(scheme->nix
    (let ((proc (thrush (lambda lists
                          (apply values (map reverse lists)))
                        (lambda lists
                          (apply values (map list->vector lists)))
                        (lambda vectors
                          (apply values (map vector->list vectors)))
                        list)))
      (proc `(1 2) `(3 4) `(5 6))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·[·(2)·(1)·]·[·(4)·(3)·]·[·(6)·(5)·]·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((proc (λ~> (lambda lists
                       (apply values (map reverse lists)))
                     (lambda lists
                       (apply values (map list->vector lists)))
                     (lambda vectors
                       (apply values (map vector->list vectors)))
                     list)))
      (proc `(1 2) `(3 4) `(5 6))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·[·(2)·(1)·]·[·(4)·(3)·]·[·(6)·(5)·]·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((proc (lambda~> (lambda lists
                            (apply values (map reverse lists)))
                          (lambda lists
                            (apply values (map list->vector lists)))
                          (lambda vectors
                            (apply values (map vector->list vectors)))
                          list)))
      (proc `(1 2) `(3 4) `(5 6))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·[·(2)·(1)·]·[·(4)·(3)·]·[·(6)·(5)·]·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let-syntax
        ((macro (λσ~> reverse
                      list->vector
                      vector->list
                      (cut map number->string <>))))
      (macro `(1 2 3 4 5 6))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·("6")·("5")·("4")·("3")·("2")·("1")·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let-syntax
        ((macro (λσ~> + - (cut * <> 4))))
      (macro 1 2 3 4 5 6)))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(-84)·])],[])

m4_define([sexpr],
  [(scheme->nix (σ~> 7 (cut * <> 3) - (cut * <> 4)))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(-84)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let-syntax ((macro (thrush*-syntax `(1 2 3 4 5 6))))
        (macro reverse
               list->vector
               vector->list
               (cut map number->string <>))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·("6")·("5")·("4")·("3")·("2")·("1")·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let-syntax ((macro (σ~>* 1 2 3 4 5 6)))
      (macro + - (cut * <> 4))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(-84)·])],[])

m4_define([sexpr],
  [(scheme->nix (thrush+ '\''foo symbol->string string-length))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(3)·])],[])

m4_define([sexpr],
  [(scheme->nix (~> 3 (cut + <> 5) (cut / 13 <>) number->string))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([("13/8")·])],[])

m4_define([sexpr],
  [(scheme->nix (~> 3))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(3)·])],[])

m4_define([sexpr],
  [(scheme->nix ((thrush* "foo" "bar") string-append string-length))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(6)·])],[])

m4_define([sexpr],
  [(scheme->nix ((~>* 1 2 3) + even?))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_true])],[])

m4_define([sexpr],
  [(scheme->nix ((thrush-and (cut + <> 3) (cut = <> 5)) 2))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_true])],[])

m4_define([sexpr],
dnl  Purposely use procedures that require the short circuit.
  [(scheme->nix ((thrush-and (cut + <> 3) (cut = <> 2) + - * /) 2))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_false])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((proc (λand~> (lambda lists
                          (apply values (map reverse lists)))
                        (lambda lists
                          (apply values (map list->vector lists)))
                        (lambda vectors
                          (apply values (map vector->list vectors)))
                        list)))
      (proc `(1 2) `(3 4) `(5 6))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·[·(2)·(1)·]·[·(4)·(3)·]·[·(6)·(5)·]·]·]])],[])

m4_define([sexpr],
dnl  Purposely use procedures that require the short circuit.
  [(scheme->nix ((lambda-and~> (cut + <> 3) (cut = <> 2) + - * /) 2))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_false])],[])

m4_define([sexpr],
  [(scheme->nix (and~> 3 (cut + <> 5) (cut / 13 <>) (cut = <> 2) number->string))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_false])],[])

m4_define([sexpr],
  [(scheme->nix (thrush+-and 3 (cut + <> 5) (cut / 13 <>) (cut = <> 2) number->string))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_false])],[])

m4_define([sexpr],
  [(scheme->nix (thrush+-and 3))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(3)·])],[])

m4_define([sexpr],
  [(scheme->nix (thrush+-and 3 (cut + <> 2)))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(5)·])],[])

m4_define([sexpr],
  [(scheme->nix ((and~>* 1 2 3) + -))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(-6)·])],[])

m4_define([sexpr],
  [(scheme->nix ((thrush*-and 1 2 3) + -))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(-6)·])],[])

m4_define([sexpr],
  [(scheme->nix ((thrush*-and 1 2 3) + (cut = <> 5) list->vector))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_false])],[])

m4_define([sexpr],
  [(scheme->nix ((and~>* 1 2 3) + (cut = <> 5) list->vector))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_false])],[])

m4_define([sexpr],
  [(scheme->nix
    (call-with-values
        (lambda () ((join (cut + <> 1) (cut - <> 1)) 0 0))
      list))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·(1)·(-1)·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (call-with-values
        (lambda () ((join* symbol->string) '\''foo '\''bar))
      list))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·("foo")·("bar")·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    ((wind-pre + string-length (lambda (s)
                                 (string-length
                                  (symbol->string s))))
     "foo" '\''bazz))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(7)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call-with-values
        (lambda ()
          ((wind-post partition length length)
           number? '\''(1 2 3 a 4 5 6 "foo" 8)))
      list))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·(7)·(2)·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
      (define (sqr x) (* x x))
      (define pythagoras ((wind + sqr sqr) sqrt))
      (list (pythagoras 3 4)
            (pythagoras 5 12))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·(5)·(13)·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (call-with-values
        (lambda () ((join* (cut + <> 1)) 1 2 3))
      list))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·(2)·(3)·(4)·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
      (define str< (wind-pre* < string-length))
      (list (str< "foo" "barrr" "bazzzzz")
            (str< "foooooo" "barrr" "baz"))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([@<:@·nix_true[]nix_false@:>@·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
      (define partition-counts (wind-post* partition length))
      (list (call-with-values
                (lambda ()
                  (partition-counts symbol? '\''(a b 1 2 3 4 5 c 5 7 8 d 8 e)))
              list)
            (call-with-values
                (lambda ()
                  (partition-counts even? '\''(1 2 3 4 5 6 7 8 9 10)))
              list))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·[·(5)·(9)·]·[·(5)·(5)·]·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
      (define str-append (wind* append string->list list->string))
      (str-append "foo" "bar" "baz")))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([("foobarbaz")·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
     ;; factorial defined by the ‘cps’ procedure.
     (define (fact n) (if (zero? n) 1 (* n (fact (- n 1)))))
     (define fact:k (cps fact))
     (call/cc (cut fact:k <> 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
     ;; factorial defined by the ‘cps’ procedure and then
     ;; redefined by the ‘uncps’ procedure.
     (define (fact n) (if (zero? n) 1 (* n (fact (- n 1)))))
     (define fact:k (cps fact))
     (define fact:u (uncps fact:k))
     (fact:u 9)))
     ])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       ;; factorial defined from more basic CPS procedures.
       (define-syntax λ
         (syntax-rules ()
           ((λ args body ...)
            (lambda args body ...))))
       (define decr:k (cps (cut - <> 1)))
       (define *:k (cps *))
       (define zero?:k (cps zero?))
       (define (fact:k k n)
         (zero?:k
          (λ (=zero?)
            (if =zero?
              (k 1)
              (decr:k
               (λ (n-1)
                 (fact:k
                  (λ (factorial)
                    (*:k k n factorial))
                  n-1))
               n)))
          n))
       (fact:k cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       ;; factorial defined with λcps~>
       (define (fact:k k n)
         (define n=0?:k (cps (lambda () (zero? n))))
         (define n-1:k (cps (lambda () (- n 1))))
         (define times_n:k (cps (lambda (x) (* n x))))
         (n=0?:k
          (lambda (z?)
            (if z?
              (k 1)
              ((λcps~> n-1:k
                       fact:k
                       times_n:k)
               k)))))
       (fact:k cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       ;; factorial defined with lambda-cps~> (including one
       ;; that is not really needed).
       (define (fact:k k n)
         (define n=0?:k (cps (lambda () (zero? n))))
         (define n-1:k (cps (lambda () (- n 1))))
         (define times_n:k (cps (lambda (x) (* n x))))
         ((lambda-cps~> n=0?:k)
          (lambda (z?)
            (if z?
              (k 1)
              ((lambda-cps~> n-1:k
                             fact:k
                             times_n:k)
               k)))))
       (fact:k cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       ;; factorial defined with cps~>*
       (define (fact:k k n)
         (define n=0?:k (cps (lambda () (zero? n))))
         (define n-1:k (cps (lambda () (- n 1))))
         (define times_n:k (cps (lambda (x) (* n x))))
         (n=0?:k
          (lambda (z?)
            (if z?
              (k 1)
              ((cps~>* k) n-1:k
                          fact:k
                          times_n:k)))))
       (fact:k cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
     ;; factorial defined by ‘define-cps-syntax’.
     (define (fact n) (if (zero? n) 1 (* n (fact (- n 1)))))
     (define-cps-syntax cps-syntax-fact fact)
     (call/cc (lambda (cc) (cps-syntax-fact cc 9)))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
     ;; factorial defined by ‘define-cps-syntax’ followed
     ;; by ‘define-uncps-syntax’.
     (define (fact n) (if (zero? n) 1 (* n (fact (- n 1)))))
     (define-cps-syntax cps-syntax-fact fact)
     (define-uncps-syntax uncps-syntax-fact cps-syntax-fact)
     (uncps-syntax-fact 9)))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
     ;; factorial defined by ‘cps-syntax’.
     (define (fact n) (if (zero? n) 1 (* n (fact (- n 1)))))
     (let-syntax ((cps-syntax-fact (cps-syntax fact)))
       (call/cc (lambda (cc) (cps-syntax-fact cc 9))))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
     ;; factorial defined by ‘cps-syntax’ followed by ‘uncps-syntax’.
     (define (fact n) (if (zero? n) 1 (* n (fact (- n 1)))))
     (let-syntax ((cps-syntax-fact (cps-syntax fact)))
       (let-syntax ((uncps-syntax-fact (uncps-syntax cps-syntax-fact)))
         (uncps-syntax-fact 9)))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       ;; factorial defined with λcpsσ~>
       (define (fact:k k n)
         (let-syntax
             ((n=0? (cpsσ (lambda () (zero? n)))))
           (let-syntax
               ((n-1 (cpsσ (lambda () (- n 1)))))
             (let-syntax
                 ((times_n (cpsσ (lambda (x) (* n x)))))
               (let-syntax ((macro1 (λcpsσ~> n-1 fact:k times_n)))
                 (n=0?
                  (lambda (z?)
                    (if z?
                      (k 1)
                      (macro1 k)))))))))
       (fact:k cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       ;; factorial defined with λcpsσ~>
       (define (fact:k k n)
         (let-syntax
             ((n=0? (cpsσ (lambda () (zero? n)))))
           (let-syntax
               ((n-1 (cpsσ (lambda () (- n 1)))))
             (let-syntax
                 ((times_n (cpsσ (lambda (x) (* n x)))))
               (let-syntax
                   ((macro1 (λcpsσ~> n-1 fact:k times_n)))
                 (n=0?
                  (lambda (z?)
                    (if z?
                      (k 1)
                      (macro1 k)))))))))
       (fact:k cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       ;; factorial defined with lambda-cps-syntax~>
       (define (fact:k k n)
         (let-syntax
             ((n=0? (cpsσ (lambda () (zero? n)))))
           (let-syntax
               ((n-1 (cpsσ (lambda () (- n 1)))))
             (let-syntax
                 ((times_n (cpsσ (lambda (x) (* n x)))))
               (let-syntax
                   ((macro1
                     (lambda-cps-syntax~> n-1 fact:k times_n)))
                 (n=0?
                  (lambda (z?)
                    (if z?
                      (k 1)
                      (macro1 k)))))))))
       (fact:k cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       ;; factorial defined with cpsσ~>*
       (define (fact:k k n)
         (let-syntax ((n=0?:k (cpsσ (lambda () (zero? n)))))
           (n=0?:k
            (lambda (z?)
              (if z?
                (k 1)
                (let-syntax
                     ((macro1 (cpsσ~>* k))
                      (n-1:k (cpsσ (lambda () (- n 1))))
                      (times_n:k (cpsσ (lambda (x) (* n x)))))
                  (macro1 n-1:k fact:k times_n:k)))))))
       (fact:k cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       ;; factorial defined with cpsσ~>* and λif
       (define (fact:k k n)
         (let-syntax ((n=0?:k (cpsσ (lambda () (zero? n)))))
           (n=0?:k
            (λif (k 1)
                 (let-syntax
                      ((macro1 (cpsσ~>* k))
                       (n-1:k (cpsσ (lambda () (- n 1))))
                       (times_n:k (cpsσ (lambda (x) (* n x)))))
                   (macro1 n-1:k fact:k times_n:k))))))
       (fact:k cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       ;; factorial defined with cps-syntax~>* and lambda-if
       (define (fact k n)
         (let-syntax ((n=0? (cps-syntax (lambda () (zero? n)))))
           (n=0?
            (lambda-if
              (k 1)
              (let-syntax
                   ((macro1 (cps-syntax~>* k))
                    (n-1 (cps-syntax (lambda () (- n 1))))
                    (times_n (cps-syntax (lambda (x) (* n x)))))
                (macro1 n-1 fact times_n))))))
       (fact cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       ;; factorial defined with cps-syntax~>* and lambda-if
       ;; and some procedures instead of macros.
       (define (fact k n)
         ((cps (lambda () (zero? n)))
          (lambda-if
            (k 1)
            (let-syntax ((macro1 (cps-syntax~>* k)))
              (macro1 (cps (lambda () (- n 1)))
                      fact
                      (cps (cut * n <>)))))))
       (fact cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       (define (fact k n)
         (letσ ((n=0? (cpsσ (lambda () (zero? n)))))
           (n=0?
            (λif (k 1)
                 (letσ ((macro1 (cpsσ~>* k))
                        (n-1 (cpsσ (lambda () (- n 1))))
                        (times_n (cpsσ (lambda (x) (* n x)))))
                   (macro1 n-1 fact times_n))))))
       (fact cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])


m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       (define (fact k n)
         (letrecσ ((n=0? (cpsσ (lambda () (zero? n)))))
           (n=0?
            (λif (k 1)
                 (letrecσ ((macro1 (cpsσ~>* k))
                           (n-1 (cpsσ (lambda () (- n 1))))
                           (times_n (cpsσ (lambda (x) (* n x)))))
                   (macro1 n-1 fact times_n))))))
       (fact cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       (define (fact k n)
         (letrecσ ((n=0? (cpsσ (lambda () (zero? n)))))
           (n=0?
            (λif (k 1)
                 (let ()
                   (defineσ macro1 (cpsσ~>* k))
                   (defineσ n-1 (cpsσ (lambda () (- n 1))))
                   (defineσ times_n (cpsσ (lambda (x) (* n x))))
                   (macro1 n-1 fact times_n))))))
       (fact cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
      (define this 1234)
      (defineσ dequote (σrules () ((¶ '\''x) x)))
      (dequote '\''this)))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(1234)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (k)
       (expand-cps-syntax~>*
        ((cpsσ~>* k 1 2)
         (cpsσ +)
         (cps-syntax number->string))))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([("3")·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (k)
       (expand-cpsσ~>*
        ((cpsσ~>* k 1 2)
         (cpsσ +)
         (cps-syntax number->string)
         (cps (cut string-append <> "-times-2")))))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([("3-times-2")·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (k)
       (expand-cpsσ~>*
        ((cpsσ~>* k 1 2)
         (lambda (k1 a b)
           ((cps~>* k1 a b) (cps +) (cps number->string)))
         (cpsσ (cut string-append <> "-times-2")))))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([("3-times-2")·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (k)
       (expand-cps-syntax~>*
        ((cps-syntax~>* k 1 2)
         (lambda-cps~> (cps +) (cps number->string))
         (cps-syntax (cut string-append <> "-times-2")))))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([("3-times-2")·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (k)
       (expand-cps-syntax~>*
        ((cps-syntax~>* k 1 2)
         (lambda-cps-syntax~> (cps-syntax +)
                              (cps-syntax number->string))
         (cps-syntax (cut string-append <> "-times-2")))))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([("3-times-2")·])],[])

m4_define([sexpr],
  [(scheme->nix
    (bind* ((((cps-syntax~>* 1 2) (cps-syntax +)) => x))
      x))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(3)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (bind* ((((thrush*-syntax 1 2 3) + -) => x)
            (((σ~>* 2 x) * (cut * <> 2)) => y)
            (((σ~>* y) number->string) => z))
      z))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([("-24")·])],[])

m4_define([sexpr],
  [(scheme->nix
    (bind* ((((cpsσ~>* 1 2 3)
              (cpsσ +) (cpsσ -)
              (cpsσ (cut * <> 4))
              (cpsσ number->string)) => z))
      z))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([("-24")·])],[])

m4_define([sexpr],
  [(scheme->nix
    (bind* ((((cpsσ~>* 1 2 3)
              (cpsσ +)
              (cpsσ -))              => x)
            (((cpsσ~>* 2 x)
              (cpsσ *)
              (cpsσ (cut * <> 2)))   => y)
            (((cpsσ~>* y)
              (cpsσ number->string)) => z))
      z))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([("-24")·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((x `()))
      (define append-args
        (lambda args
          (set! x (append x args))))
      (alternatives
       (1 2 3 4 5)
       (λcps~> (cps +) (cps append-args))
       (λcps~> (cps -) (cps append-args))
       (λcps~> (cps *) (cps append-args))
       (λcps~> (cps /) (cps append-args)))
      x))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·(15)·(-13)·(120)·(1/120)·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let-values
          ((lst (let ((x `()))
                  (define append-args
                    (lambda args
                      (set! x (append x args))))
                  (cps-alternatives
                   (lambda args (apply values x))
                   (1 2 3 4 5)
                   (λcps~> (cps +) (cps append-args))
                   (λcps~> (cps -) (cps append-args))
                   (λcps~> (cps *) (cps append-args))
                   (λcps~> (cps /) (cps append-args))))))
      lst))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·(15)·(-13)·(120)·(1/120)·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((lst '\''()))
      (define-syntax success-branch
        (syntax-rules ()
          ((¶ a b)
           (begin
             (set! lst (append lst '\''(success)))
             (set! lst (append lst '\''(a)))
             (set! lst (append lst '\''(b)))))))
      (define-syntax failure-branch
        (syntax-rules ()
          ((¶ a)
           (begin
             (set! lst (append lst '\''(failure)))
             (set! lst (append lst '\''(a)))))))
      (split-syntax (a b c => d e f)
                    (match-literal =>)
                    success-branch
                    failure-branch)
      lst))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·("success")·[·("a")·("b")·("c")·]·[·("=>")·("d")·("e")·("f")·]·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((lst '\''()))
      (define-syntax success-branch
        (syntax-rules ()
          ((¶ a b)
           (begin
             (set! lst (append lst '\''(success)))
             (set! lst (append lst '\''(a)))
             (set! lst (append lst (list (car '\''b))))
             (set! lst (append lst (list (cadr '\''b))))
             (set! lst (append lst (list (caddr '\''b))))
             (set! lst (append lst (list (cdddr '\''b))))))))
      (define-syntax failure-branch
        (syntax-rules ()
          ((¶ a)
           (begin
             (set! lst (append lst '\''(failure)))
             (set! lst (append lst '\''(a)))))))
      (split-syntax (a b c => d e . f)
                    (match-literal =>)
                    success-branch
                    failure-branch)
      lst))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·("success")·[·("a")·("b")·("c")·]·("=>")·("d")·("e")·("f")·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((lst '\''()))
      (define-syntax success-branch
        (syntax-rules ()
          ((¶ a b)
           (begin
             (set! lst (append lst '\''(success)))
             (set! lst (append lst '\''(a)))
             (set! lst (append lst (list (car '\''b))))
             (set! lst (append lst (list (cdr '\''b))))))))
      (define-syntax failure-branch
        (syntax-rules ()
          ((¶ a)
           (begin
             (set! lst (append lst '\''(failure)))
             (set! lst (append lst '\''(a)))))))
      (split-syntax (a b c d e => . f)
                    (match-literal =>)
                    success-branch
                    failure-branch)
      lst))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·("success")·[·("a")·("b")·("c")·("d")·("e")·]·("=>")·("f")·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((lst '\''()))
      (define-syntax success-branch
        (syntax-rules ()
          ((¶ a b)
           (begin
             (set! lst (append lst '\''(success)))))))
      (define-syntax failure-branch
        (syntax-rules ()
          ((¶ a)
           (begin
             (set! lst (append lst '\''(failure)))
             (set! lst (append lst (list (car '\''a))))
             (set! lst (append lst (list (cdr '\''a))))))))
      (split-syntax (a . b)
                    (match-literal =>)
                    success-branch
                    failure-branch)
      lst))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·("failure")·("a")·("b")·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((lst '\''()))
      (define-syntax success-branch
        (syntax-rules ()
          ((¶ a b)
           (begin
             (set! lst (append lst '\''(success)))
             (set! lst (append lst (vector->list '\''a)))
             (set! lst (append lst (vector->list '\''b)))))))
      (define-syntax failure-branch
        (syntax-rules ()
          ((¶ a b)
           (begin
             (set! lst (append lst '\''(failure)))
             (set! lst (append lst (vector->list '\''b)))))))
      (split-syntax @%:@(a b c => d e f)
                    (match-literal =>)
                    success-branch
                    failure-branch)
      lst))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·("success")·("a")·("b")·("c")·("=>")·("d")·("e")·("f")·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (delete-duplicate-identifiers
     (quote)
     if-bound-identifier=
     (a a a a b c d e c b d e)))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·("a")·("b")·("c")·("d")·("e")·]·]])],[])

AT_CLEANUP

# local variables:
# mode: autoconf
# coding: utf-8
# end:
