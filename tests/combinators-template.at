# Copyright © 2026 Barry Schwartz
#
# This file is part of Pipchix.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of Pipchix and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#

AT_SETUP([setup_message(combinators)])

AT_KEYWORDS([default_keywords combinators])

m4_define([sexpr],
  [(scheme->nix
    (let ((proc (thrush (lambda lists
                          (apply values (map reverse lists)))
                        (lambda lists
                          (apply values (map list->vector lists)))
                        (lambda vectors
                          (apply values (map vector->list vectors)))
                        list)))
      (proc `(1 2) `(3 4) `(5 6))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·[·(2)·(1)·]·[·(4)·(3)·]·[·(6)·(5)·]·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((proc (λ~> (lambda lists
                       (apply values (map reverse lists)))
                     (lambda lists
                       (apply values (map list->vector lists)))
                     (lambda vectors
                       (apply values (map vector->list vectors)))
                     list)))
      (proc `(1 2) `(3 4) `(5 6))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·[·(2)·(1)·]·[·(4)·(3)·]·[·(6)·(5)·]·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((proc (lambda~> (lambda lists
                            (apply values (map reverse lists)))
                          (lambda lists
                            (apply values (map list->vector lists)))
                          (lambda vectors
                            (apply values (map vector->list vectors)))
                          list)))
      (proc `(1 2) `(3 4) `(5 6))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·[·(2)·(1)·]·[·(4)·(3)·]·[·(6)·(5)·]·]·]])],[])

m4_define([sexpr],
  [(scheme->nix (thrush+ '\''foo symbol->string string-length))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(3)·])],[])

m4_define([sexpr],
  [(scheme->nix (~> 3 (cut + <> 5) (cut / 13 <>) number->string))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([("13/8")·])],[])

m4_define([sexpr],
  [(scheme->nix (~> 3))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(3)·])],[])

m4_define([sexpr],
  [(scheme->nix ((thrush* "foo" "bar") string-append string-length))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(6)·])],[])

m4_define([sexpr],
  [(scheme->nix ((~>* 1 2 3) + even?))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_true])],[])

m4_define([sexpr],
  [(scheme->nix ((thrush-and (cut + <> 3) (cut = <> 5)) 2))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_true])],[])

m4_define([sexpr],
dnl  Purposely use procedures that require the short circuit.
  [(scheme->nix ((thrush-and (cut + <> 3) (cut = <> 2) + - * /) 2))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_false])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ((proc (λand~> (lambda lists
                          (apply values (map reverse lists)))
                        (lambda lists
                          (apply values (map list->vector lists)))
                        (lambda vectors
                          (apply values (map vector->list vectors)))
                        list)))
      (proc `(1 2) `(3 4) `(5 6))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·[·(2)·(1)·]·[·(4)·(3)·]·[·(6)·(5)·]·]·]])],[])

m4_define([sexpr],
dnl  Purposely use procedures that require the short circuit.
  [(scheme->nix ((lambda-and~> (cut + <> 3) (cut = <> 2) + - * /) 2))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_false])],[])

m4_define([sexpr],
  [(scheme->nix (and~> 3 (cut + <> 5) (cut / 13 <>) (cut = <> 2) number->string))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_false])],[])

m4_define([sexpr],
  [(scheme->nix (thrush+-and 3 (cut + <> 5) (cut / 13 <>) (cut = <> 2) number->string))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_false])],[])

m4_define([sexpr],
  [(scheme->nix (thrush+-and 3))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(3)·])],[])

m4_define([sexpr],
  [(scheme->nix (thrush+-and 3 (cut + <> 2)))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(5)·])],[])

m4_define([sexpr],
  [(scheme->nix ((and~>* 1 2 3) + -))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(-6)·])],[])

m4_define([sexpr],
  [(scheme->nix ((thrush*-and 1 2 3) + -))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(-6)·])],[])

m4_define([sexpr],
  [(scheme->nix ((thrush*-and 1 2 3) + (cut = <> 5) list->vector))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_false])],[])

m4_define([sexpr],
  [(scheme->nix ((and~>* 1 2 3) + (cut = <> 5) list->vector))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([nix_false])],[])

m4_define([sexpr],
  [(scheme->nix
    (call-with-values
        (lambda () ((join (cut + <> 1) (cut - <> 1)) 0 0))
      list))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·(1)·(-1)·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (call-with-values
        (lambda () ((join* symbol->string) '\''foo '\''bar))
      list))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·("foo")·("bar")·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    ((wind-pre + string-length (lambda (s)
                                 (string-length
                                  (symbol->string s))))
     "foo" '\''bazz))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(7)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call-with-values
        (lambda ()
          ((wind-post partition length length)
           number? '\''(1 2 3 a 4 5 6 "foo" 8)))
      list))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·(7)·(2)·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
      (define (sqr x) (* x x))
      (define pythagoras ((wind + sqr sqr) sqrt))
      (list (pythagoras 3 4)
            (pythagoras 5 12))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·(5)·(13)·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (call-with-values
        (lambda () ((join* (cut + <> 1)) 1 2 3))
      list))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·(2)·(3)·(4)·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
      (define str< (wind-pre* < string-length))
      (list (str< "foo" "barrr" "bazzzzz")
            (str< "foooooo" "barrr" "baz"))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([@<:@·nix_true[]nix_false@:>@·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
      (define partition-counts (wind-post* partition length))
      (list (call-with-values
                (lambda ()
                  (partition-counts symbol? '\''(a b 1 2 3 4 5 c 5 7 8 d 8 e)))
              list)
            (call-with-values
                (lambda ()
                  (partition-counts even? '\''(1 2 3 4 5 6 7 8 9 10)))
              list))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([[[·[·(5)·(9)·]·[·(5)·(5)·]·]·]])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
      (define str-append (wind* append string->list list->string))
      (str-append "foo" "bar" "baz")))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([("foobarbaz")·])],[])

m4_define([sexpr],
  [(scheme->nix
    (let ()
     ;; factorial defined by the ‘make-cps’ procedure.
     (define (fact n) (if (zero? n) 1 (* n (fact (- n 1)))))
     (define fact:k (make-cps fact))
     (call/cc (cut fact:k <> 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

m4_define([sexpr],
  [(scheme->nix
    (call/cc
     (lambda (cc)
       ;; factorial defined from more basic CPS procedures.
       (define-syntax λ
         (syntax-rules ()
           ((λ args body ...)
            (lambda args body ...))))
       (define decr:k (make-cps (cut - <> 1)))
       (define *:k (make-cps *))
       (define zero?:k (make-cps zero?))
       (define (fact:k k n)
         (zero?:k
          (λ (=zero?)
            (if =zero?
              (k 1)
              (decr:k
               (λ (n-1)
                 (fact:k
                  (λ (factorial)
                    (*:k k n factorial))
                  n-1))
               n)))
          n))
       (fact:k cc 9))))])
check_unquoted([run_scheme 'sexpr'],[0],
  [interpunct_nl([(362880)·])],[])

AT_CLEANUP

# local variables:
# mode: autoconf
# coding: utf-8
# end:
